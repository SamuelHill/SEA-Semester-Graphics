<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>netCDF4</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th bgcolor="#70b0f0" class="navbar-select"
          >&nbsp;&nbsp;&nbsp;Home&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        Module&nbsp;netCDF4
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module netCDF4</h1><p class="nomargin-top"></p>
<h1 class="heading">Introduction</h1>
    <p>Python interface to the netCDF version 4 library.  <a 
    href="http://www.unidata.ucar.edu/software/netcdf/netcdf-4" 
    target="_top">netCDF version 4</a> has many features not found in 
    earlier versions of the library and is implemented on top of <a 
    href="http://www.hdfgroup.org/HDF5" target="_top">HDF5</a>. This module
    can read and write files in both the new netCDF 4 and the old netCDF 3 
    format, and can create files that are readable by HDF5 clients. The API
    modelled after <a 
    href="http://dirac.cnrs-orleans.fr/plone/software/scientificpython/" 
    target="_top">Scientific.IO.NetCDF</a>, and should be familiar to users
    of that module.</p>
    <p>Most new features of netCDF 4 are implemented, such as multiple 
    unlimited dimensions, groups and zlib data compression.  All the new 
    numeric data types (such as 64 bit and unsigned integer types) are 
    implemented. Compound and variable length (vlen) data types are 
    supported, but the enum and opaque data types are not. Mixtures of 
    compound and vlen data types (compound types containing vlens, and 
    vlens containing compound types) are not supported.</p>
  <h1 class="heading">Download</h1>
    <ul>
      <li>
        Latest bleeding-edge code from the <a 
        href="http://github.com/Unidata/netcdf4-python" 
        target="_top">github repository</a>.
      </li>
      <li>
        Latest <a href="https://pypi.python.org/pypi/netCDF4" 
        target="_top">releases</a> (source code and windows installers).
      </li>
    </ul>
  <h1 class="heading">Requires</h1>
    <ul>
      <li>
        Python 2.5 or later (python 3 works too).
      </li>
      <li>
        numpy array module <a href="http://numpy.scipy.org" 
        target="_top">http://numpy.scipy.org</a>, version 1.3.0 or later 
        (1.5.1 or higher recommended, required if using python 3).
      </li>
      <li>
        <a href="http://cython.org" target="_top">Cython</a> is optional - 
        if it is installed setup.py will use it to recompile the Cython 
        source code into C, using conditional compilation to enable 
        features in the netCDF API that have been added since version 
        4.1.1.  If Cython is not installed, these features (such as the 
        ability to rename Group objects) will be disabled to preserve 
        backward compatibility with older versions of the netCDF library.
      </li>
      <li>
        For python &lt; 2.7, the ordereddict module <a 
        href="http://python.org/pypi/ordereddict" 
        target="_top">http://python.org/pypi/ordereddict</a>.
      </li>
      <li>
        The HDF5 C library version 1.8.4-patch1 or higher (1.8.8 or higher 
        recommended) from <a href="ftp://ftp.hdfgroup.org/HDF5/current/src"
        target="_top">ftp://ftp.hdfgroup.org/HDF5/current/src</a>. Be sure 
        to build with '<code>--enable-hl --enable-shared</code>'.
      </li>
      <li>
        <a href="http://curl.haxx.se/libcurl/" target="_top">Libcurl</a>, 
        if you want <a href="http://opendap.org/" target="_top">OPeNDAP</a>
        support.
      </li>
      <li>
        <a href="http://www.hdfgroup.org/products/hdf4/" 
        target="_top">HDF4</a>, if you want to be able to read HDF4 
        &quot;Scientific Dataset&quot; (SD) files.
      </li>
      <li>
        The netCDF-4 C library from <a 
        href="ftp://ftp.unidata.ucar.edu/pub/netcdf" 
        target="_top">ftp://ftp.unidata.ucar.edu/pub/netcdf</a>. Version 
        4.1.1 or higher is required (4.2 or higher recommended). Be sure to
        build with '<code>--enable-netcdf-4 --enable-shared</code>', and 
        set <code>CPPFLAGS=&quot;-I $HDF5_DIR/include&quot;</code> and 
        <code>LDFLAGS=&quot;-L $HDF5_DIR/lib&quot;</code>, where 
        <code>$HDF5_DIR</code> is the directory where HDF5 was installed. 
        If you want <a href="http://opendap.org/" target="_top">OPeNDAP</a>
        support, add '<code>--enable-dap</code>'. If you want HDF4 SD 
        support, add '<code>--enable-hdf4</code>' and add the location of 
        the HDF4 headers and library to <code>CPPFLAGS</code> and 
        <code>LDFLAGS</code>.
      </li>
    </ul>
  <h1 class="heading">Install</h1>
    <ul>
      <li>
        install the requisite python modules and C libraries (see above). 
        It's easiest if all the C libs are built as shared libraries.
      </li>
      <li>
        optionally, set the <code>HDF5_DIR</code> environment variable to 
        point to where HDF5 is installed (the libs in 
        <code>$HDF5_DIR/lib</code>, the headers in 
        <code>$HDF5_DIR/include</code>). If the headers and libs are 
        installed in different places, you can use <code>HDF5_INCDIR</code>
        and <code>HDF5_LIBDIR</code> to define the locations of the headers
        and libraries independently.
      </li>
      <li>
        optionally, set the <code>NETCDF4_DIR</code> (or 
        <code>NETCDF4_INCDIR</code> and <code>NETCDF4_LIBDIR</code>) 
        environment variable(s) to point to where the netCDF version 4 
        library and headers are installed.
      </li>
      <li>
        If the locations of the HDF5 and netCDF libs and headers are not 
        specified with environment variables, some standard locations will 
        be searched.
      </li>
      <li>
        if HDF5 was built as a static library  with <a 
        href="http://www.hdfgroup.org/doc_resource/SZIP/" 
        target="_top">szip</a> support, you may also need to set the 
        <code>SZIP_DIR</code> (or <code>SZIP_INCDIR</code> and 
        <code>SZIP_LIBDIR</code>) environment variable(s) to point to where
        szip is installed. Note that the netCDF library does not support 
        creating szip compressed files, but can read szip compressed files 
        if the HDF5 lib is configured to support szip.
      </li>
      <li>
        if netCDF lib was built as a static library with HDF4 and/or 
        OpenDAP support, you may also need to set <code>HDF4_DIR</code>, 
        <code>JPEG_DIR</code> and/or <code>CURL_DIR</code>.
      </li>
      <li>
        Instead of using environment variables to specify the locations of 
        the required libraries, you can either let setup.py try to 
        auto-detect their locations, or use the file <code>setup.cfg</code>
        to specify them.  To use this method, copy the file 
        <code>setup.cfg.template</code> to <code>setup.cfg</code>, then 
        open <code>setup.cfg</code> in a text editor and follow the 
        instructions in the comments for editing.  If you use 
        <code>setup.cfg</code>, environment variables will be ignored.
      </li>
      <li>
        If you are using netcdf 4.1.2 or higher, instead of setting all 
        those enviroment variables defining where libs are installed, you 
        can just set one environment variable, USE_NCCONFIG, to 1.  This 
        will tell python to run the netcdf nc-config utility to determine 
        where all the dependencies live.
      </li>
      <li>
        run <code>python setup.py build</code>, then <code>python setup.py 
        install</code> (as root if necessary).
      </li>
      <li>
        If using environment variables to specify build options, be sure to
        run 'python setup.py build' *without* using sudo.  sudo does not 
        pass environment variables. If you run 'setup.py build' first 
        without sudo, you can run 'setup.py install' with sudo.
      </li>
      <li>
        run the tests in the 'test' directory by running <code>python 
        run_all.py</code>.
      </li>
    </ul>
  <h1 class="heading">Tutorial</h1>
    <h2 class="heading">1) Creating/Opening/Closing a netCDF file</h2>
      <p>To create a netCDF file from python, you simply call the <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> 
      constructor. This is also the method used to open an existing netCDF 
      file.  If the file is open for write access (<code>w, r+</code> or 
      <code>a</code>), you may write any type of data including new 
      dimensions, groups, variables and attributes.  netCDF files come in 
      several flavors (<code>NETCDF3_CLASSIC, NETCDF3_64BIT, 
      NETCDF4_CLASSIC</code>, and <code>NETCDF4</code>). The first two 
      flavors are supported by version 3 of the netCDF library. 
      <code>NETCDF4_CLASSIC</code> files use the version 4 disk format 
      (HDF5), but do not use any features not found in the version 3 API. 
      They can be read by netCDF 3 clients only if they have been relinked 
      against the netCDF 4 library. They can also be read by HDF5 clients. 
      <code>NETCDF4</code> files use the version 4 disk format (HDF5) and 
      use the new features of the version 4 API.  The <code>netCDF4</code> 
      module can read and write files in any of these formats. When 
      creating a new file, the format may be specified using the 
      <code>format</code> keyword in the <code>Dataset</code> constructor.
      The default format is <code>NETCDF4</code>. To see how a given file 
      is formatted, you can examine the <code>data_model</code> <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> attribute.
      Closing the netCDF file is accomplished via the <a 
      href="netCDF4.Dataset-class.html#close" class="link">close</a> method
      of the <a href="netCDF4.Dataset-class.html" class="link">Dataset</a> 
      instance.</p>
      <p>Here's an example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> netCDF4 <span class="py-keyword">import</span> Dataset
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp = Dataset(<span class="py-string">'test.nc'</span>, <span class="py-string">'w'</span>, format=<span class="py-string">'NETCDF4'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.data_model
<span class="py-output">NETCDF4</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.close()</pre>
      <p>Remote <a href="http://opendap.org" 
      target="_top">OPeNDAP</a>-hosted datasets can be accessed for reading
      over http if a URL is provided to the <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> 
      constructor instead of a filename.  However, this requires that the 
      netCDF library be built with OPenDAP support, via the 
      <code>--enable-dap</code> configure option (added in version 
      4.0.1).</p>
    <h2 class="heading">2) Groups in a netCDF file</h2>
      <p>netCDF version 4 added support for organizing data in hierarchical
      groups, which are analagous to directories in a filesystem. Groups 
      serve as containers for variables, dimensions and attributes, as well
      as other groups.  A <code>netCDF4.Dataset</code> defines creates a 
      special group, called the 'root group', which is similar to the root 
      directory in a unix filesystem.  To create <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instances, use
      the <a href="netCDF4.Dataset-class.html#createGroup" 
      class="link">createGroup</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance. <a 
      href="netCDF4.Dataset-class.html#createGroup" 
      class="link">createGroup</a> takes a single argument, a python string
      containing the name of the new group. The new <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instances 
      contained within the root group can be accessed by name using the 
      <code>groups</code> dictionary attribute of the <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> instance.
      Only <code>NETCDF4</code> formatted files support Groups, if you try 
      to create a Group in a netCDF 3 file you will get an error 
      message.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp = Dataset(<span class="py-string">'test.nc'</span>, <span class="py-string">'a'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>fcstgrp = rootgrp.createGroup(<span class="py-string">'forecasts'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>analgrp = rootgrp.createGroup(<span class="py-string">'analyses'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.groups
<span class="py-output">OrderedDict([('forecasts', &lt;netCDF4.Group object at 0x1b4b7b0&gt;),</span>
<span class="py-output">             ('analyses', &lt;netCDF4.Group object at 0x1b4b970&gt;)])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Groups can exist within groups in a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a>, just as 
      directories exist within directories in a unix filesystem. Each <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance has a
      <code>'groups'</code> attribute dictionary containing all of the 
      group instances contained within that group. Each <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance also 
      has a <code>'path'</code> attribute that contains a simulated unix 
      directory path to that group.</p>
      <p>Here's an example that shows how to navigate all the groups in a 
      <a href="netCDF4.Dataset-class.html" class="link">Dataset</a>. The 
      function <code>walktree</code> is a Python generator that is used to 
      walk the directory tree. Note that printing the <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> object yields 
      summary information about it's contents.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>fcstgrp1 = fcstgrp.createGroup(<span class="py-string">'model1'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>fcstgrp2 = fcstgrp.createGroup(<span class="py-string">'model2'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">def</span> <span class="py-defname">walktree</span>(top):
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-builtin">values</span> = top.groups.values()
<span class="py-prompt">&gt;&gt;&gt; </span>    yield <span class="py-builtin">values</span>
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-keyword">for</span> value <span class="py-keyword">in</span> top.groups.values():
<span class="py-prompt">&gt;&gt;&gt; </span>        <span class="py-keyword">for</span> children <span class="py-keyword">in</span> walktree(value):
<span class="py-prompt">&gt;&gt;&gt; </span>            yield children
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> children <span class="py-keyword">in</span> walktree(rootgrp):
<span class="py-prompt">&gt;&gt;&gt; </span>     <span class="py-keyword">for</span> child <span class="py-keyword">in</span> children:
<span class="py-prompt">&gt;&gt;&gt; </span>         <span class="py-keyword">print</span> child
<span class="py-output">&lt;type 'netCDF4.Dataset'&gt;</span>
<span class="py-output">root group (NETCDF4 file format):</span>
<span class="py-output">    dimensions: </span>
<span class="py-output">    variables: </span>
<span class="py-output">        groups: forecasts, analyses</span>
<span class="py-output">&lt;type 'netCDF4.Group'&gt;</span>
<span class="py-output">group /forecasts:</span>
<span class="py-output">    dimensions:</span>
<span class="py-output">    variables:</span>
<span class="py-output">    groups: model1, model2</span>
<span class="py-output">&lt;type 'netCDF4.Group'&gt;</span>
<span class="py-output">group /analyses:</span>
<span class="py-output">    dimensions:</span>
<span class="py-output">    variables:</span>
<span class="py-output">    groups:</span>
<span class="py-output">&lt;type 'netCDF4.Group'&gt;</span>
<span class="py-output">group /forecasts/model1:</span>
<span class="py-output">    dimensions:</span>
<span class="py-output">    variables:</span>
<span class="py-output">    groups:</span>
<span class="py-output">&lt;type 'netCDF4.Group'&gt;</span>
<span class="py-output">group /forecasts/model2:</span>
<span class="py-output">    dimensions:</span>
<span class="py-output">    variables:</span>
<span class="py-output">    groups:</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
    <h2 class="heading">3) Dimensions in a netCDF file</h2>
      <p>netCDF defines the sizes of all variables in terms of dimensions, 
      so before any variables can be created the dimensions they use must 
      be created first. A special case, not often used in practice, is that
      of a scalar variable, which has no dimensions. A dimension is created
      using the <a href="netCDF4.Dataset-class.html#createDimension" 
      class="link">createDimension</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance. A 
      Python string is used to set the name of the dimension, and an 
      integer value is used to set the size. To create an unlimited 
      dimension (a dimension that can be appended to), the size value is 
      set to <code>None</code> or 0. In this example, there both the 
      <code>time</code> and <code>level</code> dimensions are unlimited.  
      Having more than one unlimited dimension is a new netCDF 4 feature, 
      in netCDF 3 files there may be only one, and it must be the first 
      (leftmost) dimension of the variable.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>level = rootgrp.createDimension(<span class="py-string">'level'</span>, None)
<span class="py-prompt">&gt;&gt;&gt; </span>time = rootgrp.createDimension(<span class="py-string">'time'</span>, None)
<span class="py-prompt">&gt;&gt;&gt; </span>lat = rootgrp.createDimension(<span class="py-string">'lat'</span>, 73)
<span class="py-prompt">&gt;&gt;&gt; </span>lon = rootgrp.createDimension(<span class="py-string">'lon'</span>, 144)</pre>
      <p>All of the <a href="netCDF4.Dimension-class.html" 
      class="link">Dimension</a> instances are stored in a python 
      dictionary.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.dimensions
<span class="py-output">OrderedDict([('level', &lt;netCDF4.Dimension object at 0x1b48030&gt;),</span>
<span class="py-output">             ('time', &lt;netCDF4.Dimension object at 0x1b481c0&gt;),</span>
<span class="py-output">             ('lat', &lt;netCDF4.Dimension object at 0x1b480f8&gt;),</span>
<span class="py-output">             ('lon', &lt;netCDF4.Dimension object at 0x1b48a08&gt;)])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Calling the python <code>len</code> function with a <a 
      href="netCDF4.Dimension-class.html" class="link">Dimension</a> 
      instance returns the current size of that dimension. The <a 
      href="netCDF4.Dimension-class.html#isunlimited" 
      class="link">isunlimited</a> method of a <a 
      href="netCDF4.Dimension-class.html" class="link">Dimension</a> 
      instance can be used to determine if the dimensions is unlimited, or 
      appendable.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> len(lon)
<span class="py-output">144</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> len.is_unlimited()
<span class="py-output">False</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> time.is_unlimited()
<span class="py-output">True</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Printing the <a href="netCDF4.Dimension-class.html" 
      class="link">Dimension</a> object provides useful summary info, 
      including the name and length of the dimension, and whether it is 
      unlimited.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> dimobj <span class="py-keyword">in</span> rootgrp.dimensions.values():
<span class="py-prompt">&gt;&gt;&gt; </span>   <span class="py-keyword">print</span> dimobj
<span class="py-output">&lt;type 'netCDF4.Dimension'&gt; (unlimited): name = 'level', size = 0</span>
<span class="py-output">&lt;type 'netCDF4.Dimension'&gt; (unlimited): name = 'time', size = 0</span>
<span class="py-output">&lt;type 'netCDF4.Dimension'&gt;: name = 'lat', size = 73</span>
<span class="py-output">&lt;type 'netCDF4.Dimension'&gt;: name = 'lon', size = 144</span>
<span class="py-output">&lt;type 'netCDF4.Dimension'&gt; (unlimited): name = 'time', size = 0</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p><a href="netCDF4.Dimension-class.html" class="link">Dimension</a> 
      names can be changed using the <a 
      href="netCDF4.Dataset-class.html#renameDimension" 
      class="link">renameDimension</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance.</p>
    <h2 class="heading">4) Variables in a netCDF file</h2>
      <p>netCDF variables behave much like python multidimensional array 
      objects supplied by the <a href="http://numpy.scipy.org" 
      target="_top">numpy module</a>. However, unlike numpy arrays, netCDF4
      variables can be appended to along one or more 'unlimited' 
      dimensions. To create a netCDF variable, use the <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance. The 
      <a href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a> method has two mandatory arguments, 
      the variable name (a Python string), and the variable datatype. The 
      variable's dimensions are given by a tuple containing the dimension 
      names (defined previously with <a 
      href="netCDF4.Dataset-class.html#createDimension" 
      class="link">createDimension</a>). To create a scalar variable, 
      simply leave out the dimensions keyword. The variable primitive 
      datatypes correspond to the dtype attribute of a numpy array. You can
      specify the datatype as a numpy dtype object, or anything that can be
      converted to a numpy dtype object.  Valid datatype specifiers 
      include: <code>'f4'</code> (32-bit floating point), <code>'f8'</code>
      (64-bit floating point), <code>'i4'</code> (32-bit signed integer), 
      <code>'i2'</code> (16-bit signed integer), <code>'i8'</code> (64-bit 
      singed integer), <code>'i1'</code> (8-bit signed integer), 
      <code>'u1'</code> (8-bit unsigned integer), <code>'u2'</code> (16-bit
      unsigned integer), <code>'u4'</code> (32-bit unsigned integer), 
      <code>'u8'</code> (64-bit unsigned integer), or <code>'S1'</code> 
      (single-character string).  The old Numeric single-character 
      typecodes (<code>'f'</code>,<code>'d'</code>,<code>'h'</code>, 
      <code>'s'</code>,<code>'b'</code>,<code>'B'</code>,<code>'c'</code>,<code>'i'</code>,<code>'l'</code>),
      corresponding to 
      (<code>'f4'</code>,<code>'f8'</code>,<code>'i2'</code>,<code>'i2'</code>,<code>'i1'</code>,<code>'i1'</code>,<code>'S1'</code>,<code>'i4'</code>,<code>'i4'</code>),
      will also work. The unsigned integer types and the 64-bit integer 
      type can only be used if the file format is <code>NETCDF4</code>.</p>
      <p>The dimensions themselves are usually also defined as variables, 
      called coordinate variables. The <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a> method returns an instance of the <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> class 
      whose methods can be used later to access and set variable data and 
      attributes.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>times = rootgrp.createVariable(<span class="py-string">'time'</span>,<span class="py-string">'f8'</span>,(<span class="py-string">'time'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span>levels = rootgrp.createVariable(<span class="py-string">'level'</span>,<span class="py-string">'i4'</span>,(<span class="py-string">'level'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span>latitudes = rootgrp.createVariable(<span class="py-string">'latitude'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'lat'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span>longitudes = rootgrp.createVariable(<span class="py-string">'longitude'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'lon'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># two dimensions unlimited.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>temp = rootgrp.createVariable(<span class="py-string">'temp'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'time'</span>,<span class="py-string">'level'</span>,<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>,))</pre>
      <p>All of the variables in the <a href="netCDF4.Dataset-class.html" 
      class="link">Dataset</a> or <a href="netCDF4.Group-class.html" 
      class="link">Group</a> are stored in a Python dictionary, in the same
      way as the dimensions:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.variables
<span class="py-output">OrderedDict([('time', &lt;netCDF4.Variable object at 0x1b4ba70&gt;),</span>
<span class="py-output">             ('level', &lt;netCDF4.Variable object at 0x1b4bab0&gt;), </span>
<span class="py-output">             ('latitude', &lt;netCDF4.Variable object at 0x1b4baf0&gt;),</span>
<span class="py-output">             ('longitude', &lt;netCDF4.Variable object at 0x1b4bb30&gt;),</span>
<span class="py-output">             ('temp', &lt;netCDF4.Variable object at 0x1b4bb70&gt;)])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>To get summary info on a <a href="netCDF4.Variable-class.html" 
      class="link">Variable</a> instance in an interactive session, just 
      print it.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.variables[<span class="py-string">'temp'</span>]
<span class="py-output">&lt;type 'netCDF4.Variable'&gt;</span>
<span class="py-output">float32 temp(time, level, lat, lon)</span>
<span class="py-output">    least_significant_digit: 3</span>
<span class="py-output">    units: K</span>
<span class="py-output">unlimited dimensions: time, level</span>
<span class="py-output">current shape = (0, 0, 73, 144)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p><a href="netCDF4.Variable-class.html" class="link">Variable</a> 
      names can be changed using the <a 
      href="netCDF4.Dataset-class.html#renameVariable" 
      class="link">renameVariable</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> 
      instance.</p>
    <h2 class="heading">5) Attributes in a netCDF file</h2>
      <p>There are two types of attributes in a netCDF file, global and 
      variable. Global attributes provide information about a group, or the
      entire dataset, as a whole. <a href="netCDF4.Variable-class.html" 
      class="link">Variable</a> attributes provide information about one of
      the variables in a group. Global attributes are set by assigning 
      values to <a href="netCDF4.Dataset-class.html" 
      class="link">Dataset</a> or <a href="netCDF4.Group-class.html" 
      class="link">Group</a> instance variables. <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> 
      attributes are set by assigning values to <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> 
      instances variables. Attributes can be strings, numbers or sequences.
      Returning to our example,</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> time
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.description = <span class="py-string">'bogus example script'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.history = <span class="py-string">'Created '</span> + time.ctime(time.time())
<span class="py-prompt">&gt;&gt;&gt; </span>rootgrp.source = <span class="py-string">'netCDF4 python module tutorial'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>latitudes.units = <span class="py-string">'degrees north'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>longitudes.units = <span class="py-string">'degrees east'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>levels.units = <span class="py-string">'hPa'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>temp.units = <span class="py-string">'K'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>times.units = <span class="py-string">'hours since 0001-01-01 00:00:00.0'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>times.calendar = <span class="py-string">'gregorian'</span></pre>
      <p>The <a href="netCDF4.Dataset-class.html#ncattrs" 
      class="link">ncattrs</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a>, <a 
      href="netCDF4.Group-class.html" class="link">Group</a> or <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> instance
      can be used to retrieve the names of all the netCDF attributes. This 
      method is provided as a convenience, since using the built-in 
      <code>dir</code> Python function will return a bunch of private 
      methods and attributes that cannot (or should not) be modified by the
      user.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> name <span class="py-keyword">in</span> rootgrp.ncattrs():
<span class="py-prompt">&gt;&gt;&gt; </span>    <span class="py-keyword">print</span> <span class="py-string">'Global attr'</span>, name, <span class="py-string">'='</span>, getattr(rootgrp,name)
<span class="py-output">Global attr description = bogus example script</span>
<span class="py-output">Global attr history = Created Mon Nov  7 10.30:56 2005</span>
<span class="py-output">Global attr source = netCDF4 python module tutorial</span></pre>
      <p>The <code>__dict__</code> attribute of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a>, <a 
      href="netCDF4.Group-class.html" class="link">Group</a> or <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> instance
      provides all the netCDF attribute name/value pairs in a python 
      dictionary:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> rootgrp.__dict__
<span class="py-output">OrderedDict([(u'description', u'bogus example script'),</span>
<span class="py-output">             (u'history', u'Created Thu Mar  3 19:30:33 2011'), </span>
<span class="py-output">             (u'source', u'netCDF4 python module tutorial')])</span></pre>
      <p>Attributes can be deleted from a netCDF <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a>, <a 
      href="netCDF4.Group-class.html" class="link">Group</a> or <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> using 
      the python <code>del</code> statement (i.e. <code>del grp.foo</code> 
      removes the attribute <code>foo</code> the the group 
      <code>grp</code>).</p>
    <h2 class="heading">6) Writing data to and retrieving data from a netCDF variable</h2>
      <p>Now that you have a netCDF <a href="netCDF4.Variable-class.html" 
      class="link">Variable</a> instance, how do you put data into it? You 
      can just treat it like an array and assign data to a slice.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> numpy 
<span class="py-prompt">&gt;&gt;&gt; </span>lats =  numpy.arange(-90,91,2.5)
<span class="py-prompt">&gt;&gt;&gt; </span>lons =  numpy.arange(-180,180,2.5)
<span class="py-prompt">&gt;&gt;&gt; </span>latitudes[:] = lats
<span class="py-prompt">&gt;&gt;&gt; </span>longitudes[:] = lons
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'latitudes =\n'</span>,latitudes[:]
<span class="py-output">latitudes =</span>
<span class="py-output">[-90.  -87.5 -85.  -82.5 -80.  -77.5 -75.  -72.5 -70.  -67.5 -65.  -62.5</span>
<span class="py-output"> -60.  -57.5 -55.  -52.5 -50.  -47.5 -45.  -42.5 -40.  -37.5 -35.  -32.5</span>
<span class="py-output"> -30.  -27.5 -25.  -22.5 -20.  -17.5 -15.  -12.5 -10.   -7.5  -5.   -2.5</span>
<span class="py-output">   0.    2.5   5.    7.5  10.   12.5  15.   17.5  20.   22.5  25.   27.5</span>
<span class="py-output">  30.   32.5  35.   37.5  40.   42.5  45.   47.5  50.   52.5  55.   57.5</span>
<span class="py-output">  60.   62.5  65.   67.5  70.   72.5  75.   77.5  80.   82.5  85.   87.5</span>
<span class="py-output">  90. ]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Unlike NumPy's array objects, netCDF <a 
      href="netCDF4.Variable-class.html" class="link">Variable</a> objects 
      with unlimited dimensions will grow along those dimensions if you 
      assign data outside the currently defined range of indices.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># append along two unlimited dimensions by assigning to slice.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>nlats = len(rootgrp.dimensions[<span class="py-string">'lat'</span>])
<span class="py-prompt">&gt;&gt;&gt; </span>nlons = len(rootgrp.dimensions[<span class="py-string">'lon'</span>])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'temp shape before adding data = '</span>,temp.shape
<span class="py-output">temp shape before adding data =  (0, 0, 73, 144)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy.random <span class="py-keyword">import</span> uniform
<span class="py-prompt">&gt;&gt;&gt; </span>temp[0:5,0:10,:,:] = uniform(size=(5,10,nlats,nlons))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'temp shape after adding data = '</span>,temp.shape
<span class="py-output">temp shape after adding data =  (6, 10, 73, 144)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># levels have grown, but no values yet assigned.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'levels shape after adding pressure data = '</span>,levels.shape
<span class="py-output">levels shape after adding pressure data =  (10,)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Note that the size of the levels variable grows when data is 
      appended along the <code>level</code> dimension of the variable 
      <code>temp</code>, even though no data has yet been assigned to 
      levels.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># now, assign data to levels dimension variable.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>levels[:] =  [1000.,850.,700.,500.,300.,250.,200.,150.,100.,50.]</pre>
      <p>However, that there are some differences between NumPy and netCDF 
      variable slicing rules. Slices behave as usual, being specified as a 
      <code>start:stop:step</code> triplet. Using a scalar integer index 
      <code>i</code> takes the ith element and reduces the rank of the 
      output array by one. Boolean array and integer sequence indexing 
      behaves differently for netCDF variables than for numpy arrays.  Only
      1-d boolean arrays and integer sequences are allowed, and these 
      indices work independently along each dimension (similar to the way 
      vector subscripts work in fortran).  This means that</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>temp[0, 0, [0,1,2,3], [0,1,2,3]]</pre>
      <p>returns an array of shape (4,4) when slicing a netCDF variable, 
      but for a numpy array it returns an array of shape (4,). Similarly, a
      netCDF variable of shape <code>(2,3,4,5)</code> indexed with 
      <code>[0, array([True, False, True]), array([False, True, True, 
      True]), :]</code> would return a <code>(2, 3, 5)</code> array. In 
      NumPy, this would raise an error since it would be equivalent to 
      <code>[0, [0,1], [1,2,3], :]</code>. While this behaviour can cause 
      some confusion for those used to NumPy's 'fancy indexing' rules, it 
      provides a very powerful way to extract data from multidimensional 
      netCDF variables by using logical operations on the dimension arrays 
      to create slices.</p>
      <p>For example,</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>tempdat = temp[::2, [1,3,6], lats&gt;0, lons&gt;0]</pre>
      <p>will extract time indices 0,2 and 4, pressure levels 850, 500 and 
      200 hPa, all Northern Hemisphere latitudes and Eastern Hemisphere 
      longitudes, resulting in a numpy array of shape  (3, 3, 36, 71).</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'shape of fancy temp slice = '</span>,tempdat.shape
<span class="py-output">shape of fancy temp slice =  (3, 3, 36, 71)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Time coordinate values pose a special challenge to netCDF users.  
      Most metadata standards (such as CF and COARDS) specify that time 
      should be measure relative to a fixed date using a certain calendar, 
      with units specified like <code>hours since YY:MM:DD hh-mm-ss</code>.
      These units can be awkward to deal with, without a utility to convert
      the values to and from calendar dates.  The functione called <a 
      href="netCDF4-module.html#num2date" class="link">num2date</a> and <a 
      href="netCDF4-module.html#date2num" class="link">date2num</a> are 
      provided with this package to do just that.  Here's an example of how
      they can be used:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># fill in times.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> datetime <span class="py-keyword">import</span> datetime, timedelta
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> netCDF4 <span class="py-keyword">import</span> num2date, date2num
<span class="py-prompt">&gt;&gt;&gt; </span>dates = [datetime(2001,3,1)+n*timedelta(hours=12) <span class="py-keyword">for</span> n <span class="py-keyword">in</span> range(temp.shape[0])]
<span class="py-prompt">&gt;&gt;&gt; </span>times[:] = date2num(dates,units=times.units,calendar=times.calendar)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'time values (in units %s): '</span> % times.units+<span class="py-string">'\n'</span>,times[:]
<span class="py-output">time values (in units hours since January 1, 0001): </span>
<span class="py-output">[ 17533056.  17533068.  17533080.  17533092.  17533104.]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span>dates = num2date(times[:],units=times.units,calendar=times.calendar)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'dates corresponding to time values:\n'</span>,dates
<span class="py-output">dates corresponding to time values:</span>
<span class="py-output">[2001-03-01 00:00:00 2001-03-01 12:00:00 2001-03-02 00:00:00</span>
<span class="py-output"> 2001-03-02 12:00:00 2001-03-03 00:00:00]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p><a href="netCDF4-module.html#num2date" class="link">num2date</a> 
      converts numeric values of time in the specified <code>units</code> 
      and <code>calendar</code> to datetime objects, and <a 
      href="netCDF4-module.html#date2num" class="link">date2num</a> does 
      the reverse. All the calendars currently defined in the <a 
      href="http://cf-pcmdi.llnl.gov/documents/cf-conventions/" 
      target="_top">CF metadata convention</a> are supported. A function 
      called <a href="netCDF4-module.html#date2index" 
      class="link">date2index</a> is also provided which returns the 
      indices of a netCDF time variable corresponding to a sequence of 
      datetime instances.</p>
    <h2 class="heading">7) Reading data from a multi-file netCDF dataset.</h2>
      <p>If you want to read data from a variable that spans multiple 
      netCDF files, you can use the <a href="netCDF4.MFDataset-class.html" 
      class="link">MFDataset</a> class to read the data as if it were 
      contained in a single file. Instead of using a single filename to 
      create a <a href="netCDF4.Dataset-class.html" 
      class="link">Dataset</a> instance, create a <a 
      href="netCDF4.MFDataset-class.html" class="link">MFDataset</a> 
      instance with either a list of filenames, or a string with a wildcard
      (which is then converted to a sorted list of files using the python 
      glob module). Variables in the list of files that share the same 
      unlimited dimension are aggregated together, and can be sliced across
      multiple files.  To illustrate this, let's first create a bunch of 
      netCDF files with the same variable (with the same unlimited 
      dimension).  The files must in be in <code>NETCDF3_64BIT</code>, 
      <code>NETCDF3_CLASSIC</code> or <code>NETCDF4_CLASSIC format</code> 
      (<code>NETCDF4</code> formatted multi-file datasets are not 
      supported).</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> nfile <span class="py-keyword">in</span> range(10):
<span class="py-prompt">&gt;&gt;&gt; </span>    f = Dataset(<span class="py-string">'mftest'</span>+repr(nfile)+<span class="py-string">'.nc'</span>,<span class="py-string">'w'</span>,format=<span class="py-string">'NETCDF4_CLASSIC'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>    f.createDimension(<span class="py-string">'x'</span>,None)
<span class="py-prompt">&gt;&gt;&gt; </span>    x = f.createVariable(<span class="py-string">'x'</span>,<span class="py-string">'i'</span>,(<span class="py-string">'x'</span>,))
<span class="py-prompt">&gt;&gt;&gt; </span>    x[0:10] = numpy.arange(nfile*10,10*(nfile+1))
<span class="py-prompt">&gt;&gt;&gt; </span>    f.close()</pre>
      <p>Now read all the files back in at once with <a 
      href="netCDF4.MFDataset-class.html" class="link">MFDataset</a></p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> netCDF4 <span class="py-keyword">import</span> MFDataset
<span class="py-prompt">&gt;&gt;&gt; </span>f = MFDataset(<span class="py-string">'mftest*nc'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> f.variables[<span class="py-string">'x'</span>][:]
<span class="py-output">[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</span>
<span class="py-output"> 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49</span>
<span class="py-output"> 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74</span>
<span class="py-output"> 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Note that MFDataset can only be used to read, not write, 
      multi-file datasets.</p>
    <h2 class="heading">8) Efficient compression of netCDF variables</h2>
      <p>Data stored in netCDF 4 <a href="netCDF4.Variable-class.html" 
      class="link">Variable</a> objects can be compressed and decompressed 
      on the fly. The parameters for the compression are determined by the 
      <code>zlib</code>, <code>complevel</code> and <code>shuffle</code> 
      keyword arguments to the <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a> method. To turn on compression, set 
      <code>zlib=True</code>.  The <code>complevel</code> keyword regulates
      the speed and efficiency of the compression (1 being fastest, but 
      lowest compression ratio, 9 being slowest but best compression 
      ratio). The default value of <code>complevel</code> is 4. Setting 
      <code>shuffle=False</code> will turn off the HDF5 shuffle filter, 
      which de-interlaces a block of data before compression by reordering 
      the bytes.  The shuffle filter can significantly improve compression 
      ratios, and is on by default.  Setting <code>fletcher32</code> 
      keyword argument to <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a> to <code>True</code> (it's 
      <code>False</code> by default) enables the Fletcher32 checksum 
      algorithm for error detection. It's also possible to set the HDF5 
      chunking parameters and endian-ness of the binary data stored in the 
      HDF5 file with the <code>chunksizes</code> and <code>endian</code> 
      keyword arguments to <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a>.  These keyword arguments only are 
      relevant for <code>NETCDF4</code> and <code>NETCDF4_CLASSIC</code> 
      files (where the underlying file format is HDF5) and are silently 
      ignored if the file format is <code>NETCDF3_CLASSIC</code> or 
      <code>NETCDF3_64BIT</code>,</p>
      <p>If your data only has a certain number of digits of precision (say
      for example, it is temperature data that was measured with a 
      precision of 0.1 degrees), you can dramatically improve zlib 
      compression by quantizing (or truncating) the data using the 
      <code>least_significant_digit</code> keyword argument to <a 
      href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a>. The least significant digit is the 
      power of ten of the smallest decimal place in the data that is a 
      reliable value. For example if the data has a precision of 0.1, then 
      setting <code>least_significant_digit=1</code> will cause data the 
      data to be quantized using 
      <code>numpy.around(scale*data)/scale</code>, where scale = 2**bits, 
      and bits is determined so that a precision of 0.1 is retained (in 
      this case bits=4).  Effectively, this makes the compression 'lossy' 
      instead of 'lossless', that is some precision in the data is 
      sacrificed for the sake of disk space.</p>
      <p>In our example, try replacing the line</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>temp = rootgrp.createVariable(<span class="py-string">'temp'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'time'</span>,<span class="py-string">'level'</span>,<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>,))</pre>
      <p>with</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>temp = dataset.createVariable(<span class="py-string">'temp'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'time'</span>,<span class="py-string">'level'</span>,<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>,),zlib=True)</pre>
      <p>and then</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>temp = dataset.createVariable(<span class="py-string">'temp'</span>,<span class="py-string">'f4'</span>,(<span class="py-string">'time'</span>,<span class="py-string">'level'</span>,<span class="py-string">'lat'</span>,<span class="py-string">'lon'</span>,),zlib=True,least_significant_digit=3)</pre>
      <p>and see how much smaller the resulting files are.</p>
    <h2 class="heading">9) Beyond homogenous arrays of a fixed type - compound data types</h2>
      <p>Compound data types map directly to numpy structured (a.k.a 
      'record' arrays).  Structured arrays are akin to C structs, or 
      derived types in Fortran. They allow for the construction of 
      table-like structures composed of combinations of other data types, 
      including other compound types. Compound types might be useful for 
      representing multiple parameter values at each point on a grid, or at
      each time and space location for scattered (point) data. You can then
      access all the information for a point by reading one variable, 
      instead of reading different parameters from different variables.  
      Compound data types are created from the corresponding numpy data 
      type using the <a 
      href="netCDF4.Dataset-class.html#createCompoundType" 
      class="link">createCompoundType</a> method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance. 
      Since there is no native complex data type in netcdf, compound types 
      are handy for storing numpy complex arrays.  Here's an example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>f = Dataset(<span class="py-string">'complex.nc'</span>,<span class="py-string">'w'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>size = 3 <span class="py-comment"># length of 1-d complex array</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create sample complex data.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>datac = numpy.exp(1j*(1.+numpy.linspace(0, numpy.pi, size)))
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create complex128 compound data type.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>complex128 = numpy.dtype([(<span class="py-string">'real'</span>,numpy.float64),(<span class="py-string">'imag'</span>,numpy.float64)])
<span class="py-prompt">&gt;&gt;&gt; </span>complex128_t = f.createCompoundType(complex128,<span class="py-string">'complex128'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create a variable with this data type, write some data to it.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>f.createDimension(<span class="py-string">'x_dim'</span>,None)
<span class="py-prompt">&gt;&gt;&gt; </span>v = f.createVariable(<span class="py-string">'cmplx_var'</span>,complex128_t,<span class="py-string">'x_dim'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>data = numpy.empty(size,complex128) <span class="py-comment"># numpy structured array</span>
<span class="py-prompt">&gt;&gt;&gt; </span>data[<span class="py-string">'real'</span>] = datac.real; data[<span class="py-string">'imag'</span>] = datac.imag
<span class="py-prompt">&gt;&gt;&gt; </span>v[:] = data <span class="py-comment"># write numpy structured array to netcdf compound var</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># close and reopen the file, check the contents.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>f.close(); f = Dataset(<span class="py-string">'complex.nc'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>v = f.variables[<span class="py-string">'cmplx_var'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>datain = v[:] <span class="py-comment"># read in all the data into a numpy structured array</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># create an empty numpy complex array</span>
<span class="py-prompt">&gt;&gt;&gt; </span>datac2 = numpy.empty(datain.shape,numpy.complex128)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># .. fill it with contents of structured array.</span>
<span class="py-prompt">&gt;&gt;&gt; </span>datac2.real = datain[<span class="py-string">'real'</span>]; datac2.imag = datain[<span class="py-string">'imag'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> datac.dtype,datac <span class="py-comment"># original data</span>
<span class="py-output">complex128 [ 0.54030231+0.84147098j -0.84147098+0.54030231j  -0.54030231-0.84147098j]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> datac2.dtype,datac2 <span class="py-comment"># data from file</span>
<span class="py-output">complex128 [ 0.54030231+0.84147098j -0.84147098+0.54030231j  -0.54030231-0.84147098j]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Compound types can be nested, but you must create the 'inner' ones
      first. All of the compound types defined for a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> are stored in 
      a Python dictionary, just like variables and dimensions. As always, 
      printing objects gives useful summary information in an interactive 
      session:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> f
<span class="py-output">&lt;type 'netCDF4.Dataset'&gt;</span>
<span class="py-output">root group (NETCDF4 file format):</span>
<span class="py-output">    dimensions: x_dim</span>
<span class="py-output">    variables: cmplx_var</span>
<span class="py-output">    groups:</span>
<span class="py-output">&lt;type 'netCDF4.Variable'&gt;</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> f.variables[<span class="py-string">'cmplx_var'</span>]
<span class="py-output">compound cmplx_var(x_dim)</span>
<span class="py-output">compound data type: [('real', '&lt;f8'), ('imag', '&lt;f8')]</span>
<span class="py-output">unlimited dimensions: x_dim</span>
<span class="py-output">current shape = (3,)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> f.cmptypes
<span class="py-output">OrderedDict([('complex128', &lt;netCDF4.CompoundType object at 0x1029eb7e8&gt;)])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> f.cmptypes[<span class="py-string">'complex128'</span>]
<span class="py-output">&lt;type 'netCDF4.CompoundType'&gt;: name = 'complex128', numpy dtype = [(u'real','&lt;f8'), (u'imag', '&lt;f8')]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
    <h2 class="heading">10) Variable-length (vlen) data types.</h2>
      <p>NetCDF 4 has support for variable-length or &quot;ragged&quot; 
      arrays.  These are arrays of variable length sequences having the 
      same type. To create a variable-length data type, use the <a 
      href="netCDF4.Dataset-class.html#createVLType" 
      class="link">createVLType</a> method method of a <a 
      href="netCDF4.Dataset-class.html" class="link">Dataset</a> or <a 
      href="netCDF4.Group-class.html" class="link">Group</a> instance.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>f = Dataset(<span class="py-string">'tst_vlen.nc'</span>,<span class="py-string">'w'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>vlen_t = f.createVLType(numpy.int32, <span class="py-string">'phony_vlen'</span>)</pre>
      <p>The numpy datatype of the variable-length sequences and the name 
      of the new datatype must be specified. Any of the primitive datatypes
      can be used (signed and unsigned integers, 32 and 64 bit floats, and 
      characters), but compound data types cannot. A new variable can then 
      be created using this datatype.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = f.createDimension(<span class="py-string">'x'</span>,3)
<span class="py-prompt">&gt;&gt;&gt; </span>y = f.createDimension(<span class="py-string">'y'</span>,4)
<span class="py-prompt">&gt;&gt;&gt; </span>vlvar = f.createVariable(<span class="py-string">'phony_vlen_var'</span>, vlen_t, (<span class="py-string">'y'</span>,<span class="py-string">'x'</span>))</pre>
      <p>Since there is no native vlen datatype in numpy, vlen arrays are 
      represented in python as object arrays (arrays of dtype 
      <code>object</code>). These are arrays whose elements are Python 
      object pointers, and can contain any type of python object. For this 
      application, they must contain 1-D numpy arrays all of the same type 
      but of varying length. In this case, they contain 1-D numpy 
      <code>int32</code> arrays of random length betwee 1 and 10.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> random
<span class="py-prompt">&gt;&gt;&gt; </span>data = numpy.empty(len(y)*len(x),object)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> n <span class="py-keyword">in</span> range(len(y)*len(x)):
<span class="py-prompt">&gt;&gt;&gt; </span>   data[n] = numpy.arange(random.randint(1,10),dtype=<span class="py-string">'int32'</span>)+1
<span class="py-prompt">&gt;&gt;&gt; </span>data = numpy.reshape(data,(len(y),len(x)))
<span class="py-prompt">&gt;&gt;&gt; </span>vlvar[:] = data
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'vlen variable =\n'</span>,vlvar[:]
<span class="py-output">vlen variable =</span>
<span class="py-output">[[[ 1  2  3  4  5  6  7  8  9 10] [1 2 3 4 5] [1 2 3 4 5 6 7 8]]</span>
<span class="py-output"> [[1 2 3 4 5 6 7] [1 2 3 4 5 6] [1 2 3 4 5]]</span>
<span class="py-output"> [[1 2 3 4 5] [1 2 3 4] [1]]</span>
<span class="py-output"> [[ 1  2  3  4  5  6  7  8  9 10] [ 1  2  3  4  5  6  7  8  9 10]</span>
<span class="py-output">  [1 2 3 4 5 6 7 8]]]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> f
<span class="py-output">&lt;type 'netCDF4.Dataset'&gt;</span>
<span class="py-output">root group (NETCDF4 file format):</span>
<span class="py-output">    dimensions: x, y</span>
<span class="py-output">    variables: phony_vlen_var</span>
<span class="py-output">    groups:</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> f.variables[<span class="py-string">'phony_vlen_var'</span>]
<span class="py-output">&lt;type 'netCDF4.Variable'&gt;</span>
<span class="py-output">vlen phony_vlen_var(y, x)</span>
<span class="py-output">vlen data type: int32</span>
<span class="py-output">unlimited dimensions:</span>
<span class="py-output">current shape = (4, 3)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> f.VLtypes[<span class="py-string">'phony_vlen'</span>]
<span class="py-output">&lt;type 'netCDF4.VLType'&gt;: name = 'phony_vlen', numpy dtype = int32</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>Numpy object arrays containing python strings can also be written 
      as vlen variables,  For vlen strings, you don't need to create a vlen
      data type. Instead, simply use the python <code>str</code> builtin 
      (or a numpy string datatype with fixed length greater than 1) when 
      calling the <a href="netCDF4.Dataset-class.html#createVariable" 
      class="link">createVariable</a> method.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>z = f.createDimension(<span class="py-string">'z'</span>,10)
<span class="py-prompt">&gt;&gt;&gt; </span>strvar = rootgrp.createVariable(<span class="py-string">'strvar'</span>, str, <span class="py-string">'z'</span>)</pre>
      <p>In this example, an object array is filled with random python 
      strings with random lengths between 2 and 12 characters, and the data
      in the object array is assigned to the vlen string variable.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>chars = <span class="py-string">'1234567890aabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>
<span class="py-prompt">&gt;&gt;&gt; </span>data = numpy.empty(10,<span class="py-string">'O'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> n <span class="py-keyword">in</span> range(10):
<span class="py-prompt">&gt;&gt;&gt; </span>    stringlen = random.randint(2,12)
<span class="py-prompt">&gt;&gt;&gt; </span>    data[n] = <span class="py-string">''</span>.join([random.choice(chars) <span class="py-keyword">for</span> i <span class="py-keyword">in</span> range(stringlen)])
<span class="py-prompt">&gt;&gt;&gt; </span>strvar[:] = data
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> <span class="py-string">'variable-length string variable:\n'</span>,strvar[:]
<span class="py-output">variable-length string variable:</span>
<span class="py-output">[aDy29jPt jd7aplD b8t4RM jHh8hq KtaPWF9cQj Q1hHN5WoXSiT MMxsVeq td LUzvVTzj</span>
<span class="py-output"> 5DS9X8S]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> f
<span class="py-output">&lt;type 'netCDF4.Dataset'&gt;</span>
<span class="py-output">root group (NETCDF4 file format):</span>
<span class="py-output">    dimensions: x, y, z</span>
<span class="py-output">    variables: phony_vlen_var, strvar</span>
<span class="py-output">    groups:</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> f.variables[<span class="py-string">'strvar'</span>]
<span class="py-output">&lt;type 'netCDF4.Variable'&gt;</span>
<span class="py-output">vlen strvar(z)</span>
<span class="py-output">vlen data type: &lt;type 'str'&gt;</span>
<span class="py-output">unlimited dimensions:</span>
<span class="py-output">current size = (10,)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt;</span></pre>
      <p>It is also possible to set contents of vlen string variables with 
      numpy arrays of any string or unicode data type. Note, however, that 
      accessing the contents of such variables will always return numpy 
      arrays with dtype <code>object</code>.</p>
      <p>All of the code in this tutorial is available in 
      <code>examples/tutorial.py</code>, Unit tests are in the 
      <code>test</code> directory.</p>

<hr />
<div class="fields">      <p><strong>Contact:</strong>
        Jeffrey Whitaker &lt;jeffrey.s.whitaker@noaa.gov&gt;
      </p>
      <p><strong>Copyright:</strong>
        2008 by Jeffrey Whitaker.
      </p>
      <p><strong>License:</strong>
        Permission to use, copy, modify, and distribute this software and 
        its documentation for any purpose and without fee is hereby 
        granted, provided that the above copyright notice appear in all 
        copies and that both the copyright notice and this permission 
        notice appear in supporting documentation. THE AUTHOR DISCLAIMS ALL
        WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED 
        WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE 
        AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
        OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR 
        PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER 
        TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR 
        PERFORMANCE OF THIS SOFTWARE.
      </p>
      <p><strong>Version:</strong>
        1.1.1
      </p>
</div><!-- ==================== CLASSES ==================== -->
<a name="section-Classes"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Classes</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.CompoundType-class.html" class="summary-name">CompoundType</a><br />
      A <a href="netCDF4.CompoundType-class.html" 
        class="link">CompoundType</a> instance is used to describe a 
        compound data type.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.Dataset-class.html" class="summary-name">Dataset</a><br />
      Dataset(self, filename, mode=&quot;r&quot;, clobber=True, 
        diskless=False, persist=False, keepweakref=False, format='NETCDF4')
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.Dimension-class.html" class="summary-name">Dimension</a><br />
      Dimension(self, group, name, size=None)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.Group-class.html" class="summary-name">Group</a><br />
      Group(self, parent, name)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.MFDataset-class.html" class="summary-name">MFDataset</a><br />
      MFDataset(self, files, check=False, aggdim=None, exclude=[])
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.MFTime-class.html" class="summary-name">MFTime</a><br />
      MFTime(self, time, units=None)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.VLType-class.html" class="summary-name">VLType</a><br />
      A <a href="netCDF4.VLType-class.html" class="link">VLType</a> 
        instance is used to describe a variable length (VLEN) data type.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4.Variable-class.html" class="summary-name">Variable</a><br />
      Variable(self, group, name, datatype, dimensions=(), zlib=False, 
        complevel=4, shuffle=True, fletcher32=False, contiguous=False, 
        chunksizes=None, endian='native', 
        least_significant_digit=None,fill_value=None)
    </td>
  </tr>
</table>
<!-- ==================== FUNCTIONS ==================== -->
<a name="section-Functions"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Functions</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="netCDF4-module.html#chartostring" class="summary-sig-name">chartostring</a>(<span class="summary-sig-arg">b</span>)</span><br />
      convert a character array to a string array with one less dimension.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="netCDF4-module.html#date2index" class="summary-sig-name">date2index</a>(<span class="summary-sig-arg">dates</span>,
        <span class="summary-sig-arg">nctime</span>,
        <span class="summary-sig-arg">calendar</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">select</span>=<span class="summary-sig-default">'exact'</span>)</span><br />
      Return indices of a netCDF time variable corresponding to the given 
      dates.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="netCDF4-module.html#date2num" class="summary-sig-name">date2num</a>(<span class="summary-sig-arg">dates</span>,
        <span class="summary-sig-arg">units</span>,
        <span class="summary-sig-arg">calendar</span>=<span class="summary-sig-default">'standard'</span>)</span><br />
      Return numeric time values given datetime objects.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="getlibversion"></a><span class="summary-sig-name">getlibversion</span>()</span><br />
      returns a string describing the version of the netcdf library used to
      build the module, and when it was built.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="netCDF4-module.html#num2date" class="summary-sig-name">num2date</a>(<span class="summary-sig-arg">times</span>,
        <span class="summary-sig-arg">units</span>,
        <span class="summary-sig-arg">calendar</span>=<span class="summary-sig-default">'standard'</span>)</span><br />
      Return datetime objects given numeric time values.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="netCDF4-module.html#stringtoarr" class="summary-sig-name">stringtoarr</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">NUMCHARS</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">'S'</span>)</span><br />
      convert a string to a character array of length NUMCHARS</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="netCDF4-module.html#stringtochar" class="summary-sig-name">stringtochar</a>(<span class="summary-sig-arg">a</span>)</span><br />
      convert a string array to a character array with one extra dimension</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== VARIABLES ==================== -->
<a name="section-Variables"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Variables</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="NC_DISKLESS"></a><span class="summary-name">NC_DISKLESS</span> = <code title="8">8</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__has_nc_inq_format_extended__"></a><span class="summary-name">__has_nc_inq_format_extended__</span> = <code title="0">0</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__has_nc_inq_path__"></a><span class="summary-name">__has_nc_inq_path__</span> = <code title="0">0</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__has_rename_grp__"></a><span class="summary-name">__has_rename_grp__</span> = <code title="0">0</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__hdf5libversion__"></a><span class="summary-name">__hdf5libversion__</span> = <code title="'1.8.13'"><code class="variable-quote">'</code><code class="variable-string">1.8.13</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__netcdf4libversion__"></a><span class="summary-name">__netcdf4libversion__</span> = <code title="u'4.3.3-rc1'"><code class="variable-quote">u'</code><code class="variable-string">4.3.3-rc1</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__package__"></a><span class="summary-name">__package__</span> = <code title="None">None</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="default_encoding"></a><span class="summary-name">default_encoding</span> = <code title="'utf-8'"><code class="variable-quote">'</code><code class="variable-string">utf-8</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="netCDF4-module.html#default_fillvals" class="summary-name">default_fillvals</a> = <code title="{'S1': '\x00',
 'U1': '\x00',
 'f4': 9.96920996839e+36,
 'f8': 9.96920996839e+36,
 'i1': -127,
 'i2': -32767,
 'i4': -2147483647,
 'i8': -9223372036854775806,
..."><code class="variable-group">{</code><code class="variable-quote">'</code><code class="variable-string">S1</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">\x00</code><code class="variable-quote">'</code><code class="variable-op">, </code><code class="variable-quote">'</code><code class="variable-string">U1</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">\x00</code><code class="variable-quote">'</code><code class="variable-op">, </code><code class="variable-quote">'</code><code class="variable-string">f4</code><code class="variable-quote">'</code><code class="variable-op">: </code>9.969209<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="gregorian"></a><span class="summary-name">gregorian</span> = <code title="datetime.datetime(1582, 10, 15, 0, 0)">datetime.datetime(1582, 10, 15, 0, 0)</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="is_native_big"></a><span class="summary-name">is_native_big</span> = <code title="False">False</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="is_native_little"></a><span class="summary-name">is_native_little</span> = <code title="True">True</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="python3"></a><span class="summary-name">python3</span> = <code title="False">False</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="unicode_error"></a><span class="summary-name">unicode_error</span> = <code title="'replace'"><code class="variable-quote">'</code><code class="variable-string">replace</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
</table>
<!-- ==================== FUNCTION DETAILS ==================== -->
<a name="section-FunctionDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Function Details</span></td>
</tr>
</table>
<a name="chartostring"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">chartostring</span>(<span class="sig-arg">b</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>convert a character array to a string array with one less 
  dimension.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>b</code></strong> - Input character array (numpy datatype 'S1' or 'U1'). Will be 
          converted to a array of strings, where each string has a fixed 
          length of b.shape[-1] characters.</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>A numpy string array with datatype 'SN' or 'UN' and shape 
          b.shape[:-1], where N=b.shape[-1].</dd>
  </dl>
</td></tr></table>
</div>
<a name="date2index"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">date2index</span>(<span class="sig-arg">dates</span>,
        <span class="sig-arg">nctime</span>,
        <span class="sig-arg">calendar</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">select</span>=<span class="sig-default">'exact'</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return indices of a netCDF time variable corresponding to the given 
  dates.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>dates</code></strong> - A datetime object or a sequence of datetime objects. The datetime
          objects should not include a time-zone offset.</li>
        <li><strong class="pname"><code>nctime</code></strong> - A netCDF time variable object. The nctime object must have a 
          <code>units</code> attribute.</li>
        <li><strong class="pname"><code>calendar</code></strong> - Describes the calendar used in the time calculation. Valid 
          calendars <code>'standard', 'gregorian', 'proleptic_gregorian' 
          'noleap', '365_day', '360_day', 'julian', 'all_leap', 
          '366_day'</code>. Default is <code>'standard'</code>, which is a 
          mixed Julian/Gregorian calendar If <code>calendar</code> is None,
          its value is given by <code>nctime.calendar</code> or 
          <code>standard</code> if no such attribute exists.</li>
        <li><strong class="pname"><code>select</code></strong> - <code>'exact', 'before', 'after', 'nearest'</code> The index 
          selection method. <code>exact</code> will return the indices 
          perfectly matching the dates given. <code>before</code> and 
          <code>after</code> will return the indices corresponding to the 
          dates just before or just after the given dates if an exact match
          cannot be found. <code>nearest</code> will return the indices 
          that correspond to the closest dates.</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>an index (indices) of the netCDF time variable corresponding to 
          the given datetime object(s).</dd>
  </dl>
</td></tr></table>
</div>
<a name="date2num"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">date2num</span>(<span class="sig-arg">dates</span>,
        <span class="sig-arg">units</span>,
        <span class="sig-arg">calendar</span>=<span class="sig-default">'standard'</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return numeric time values given datetime objects. The units of the 
  numeric time values are described by the <code class="link">units</code> 
  argument and the <code class="link">calendar</code> keyword. The datetime
  objects must be in UTC with no time-zone offset.  If there is a time-zone
  offset in <code>units</code>, it will be applied to the returned numeric 
  values.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>dates</code></strong> - A datetime object or a sequence of datetime objects. The datetime
          objects should not include a time-zone offset.</li>
        <li><strong class="pname"><code>units</code></strong> - a string of the form <code>'<b>time units</b> since <b>reference 
          time</b></code>' describing the time units. <b><code>time 
          units</code></b> can be days, hours, minutes, seconds, 
          milliseconds or microseconds. <b><code>reference time</code></b> 
          is the time origin. Milliseconds and microseconds can only be 
          used with the proleptic_gregorian calendar, or the standard and 
          gregorian calendars if the time origin is after 1582-10-15. A 
          valid choice would be units=<code>'milliseconds since 1800-01-01 
          00:00:00-6:00'</code>.</li>
        <li><strong class="pname"><code>calendar</code></strong> - describes the calendar used in the time calculations. All the 
          values currently defined in the <a 
          href="http://cf-pcmdi.llnl.gov/documents/cf-conventions/" 
          target="_top">CF metadata convention</a> are supported. Valid 
          calendars <code>'standard', 'gregorian', 'proleptic_gregorian' 
          'noleap', '365_day', '360_day', 'julian', 'all_leap', 
          '366_day'</code>. Default is <code>'standard'</code>, which is a 
          mixed Julian/Gregorian calendar.</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>a numeric time value, or an array of numeric time values.</dd>
  </dl>
</td></tr></table>
</div>
<a name="num2date"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">num2date</span>(<span class="sig-arg">times</span>,
        <span class="sig-arg">units</span>,
        <span class="sig-arg">calendar</span>=<span class="sig-default">'standard'</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return datetime objects given numeric time values. The units of the 
  numeric time values are described by the <code>units</code> argument and 
  the <code>calendar</code> keyword. The returned datetime objects 
  represent UTC with no time-zone offset, even if the specified 
  <code>units</code> contain a time-zone offset.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>times</code></strong> - numeric time values.</li>
        <li><strong class="pname"><code>units</code></strong> - a string of the form <code>'<b>time units</b> since <b>reference 
          time</b></code>' describing the time units. <b><code>time 
          units</code></b> can be days, hours, minutes, seconds, 
          milliseconds or microseconds. <b><code>reference time</code></b> 
          is the time origin. Milliseconds and microseconds can only be 
          used with the proleptic_gregorian calendar, or the standard and 
          gregorian calendars if the time origin is after 1582-10-15. A 
          valid choice would be units=<code>'milliseconds since 1800-01-01 
          00:00:00-6:00'</code>.</li>
        <li><strong class="pname"><code>calendar</code></strong> - describes the calendar used in the time calculations. All the 
          values currently defined in the <a 
          href="http://cf-pcmdi.llnl.gov/documents/cf-conventions/" 
          target="_top">CF metadata convention</a> are supported. Valid 
          calendars <code>'standard', 'gregorian', 'proleptic_gregorian' 
          'noleap', '365_day', '360_day', 'julian', 'all_leap', 
          '366_day'</code>. Default is <code>'standard'</code>, which is a 
          mixed Julian/Gregorian calendar.</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>a datetime instance, or an array of datetime instances.
          <p>The datetime instances returned are 'real' python datetime 
          objects if the date falls in the Gregorian calendar (i.e. 
          <code>calendar='proleptic_gregorian'</code>, or <code>calendar = 
          'standard'</code> or <code>'gregorian'</code> and the date is 
          after 1582-10-15). Otherwise, they are 'phony' datetime objects 
          which support some but not all the methods of 'real' python 
          datetime objects.  This is because the python datetime module 
          cannot the uses the <code>'proleptic_gregorian'</code> calendar, 
          even before the switch occured from the Julian calendar in 1582. 
          The datetime instances do not contain a time-zone offset, even if
          the specified <code>units</code> contains one.</p></dd>
  </dl>
</td></tr></table>
</div>
<a name="stringtoarr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">stringtoarr</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">NUMCHARS</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">'S'</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>convert a string to a character array of length NUMCHARS</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>a</code></strong> - Input python string.</li>
        <li><strong class="pname"><code>NUMCHARS</code></strong> - number of characters used to represent string (if len(a) &lt; 
          NUMCHARS, it will be padded on the right with blanks).</li>
        <li><strong class="pname"><code>dtype</code></strong> - type of numpy array to return.  Default is 'S', which means an 
          array of dtype 'S1' will be returned.  If dtype='U', a unicode 
          array (dtype = 'U1') will be returned.</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>A rank 1 numpy character array of length NUMCHARS with datatype 
          'S1' (default) or 'U1' (if dtype='U')</dd>
  </dl>
</td></tr></table>
</div>
<a name="stringtochar"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">stringtochar</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>convert a string array to a character array with one extra 
  dimension</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>a</code></strong> - Input numpy string array with numpy datatype 'SN' or 'UN', where 
          N is the number of characters in each string.  Will be converted 
          to an array of characters (datatype 'S1' or 'U1') of shape 
          a.shape + (N,).</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>A numpy character array with datatype 'S1' or 'U1' and shape 
          a.shape + (N,), where N is the length of each string in a.</dd>
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== VARIABLES DETAILS ==================== -->
<a name="section-VariablesDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Variables Details</span></td>
</tr>
</table>
<a name="default_fillvals"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">default_fillvals</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
<code class="variable-group">{</code><code class="variable-quote">'</code><code class="variable-string">S1</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">\x00</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">U1</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">\x00</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">f4</code><code class="variable-quote">'</code><code class="variable-op">: </code>9.96920996839e+36<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">f8</code><code class="variable-quote">'</code><code class="variable-op">: </code>9.96920996839e+36<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">i1</code><code class="variable-quote">'</code><code class="variable-op">: </code>-127<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">i2</code><code class="variable-quote">'</code><code class="variable-op">: </code>-32767<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">i4</code><code class="variable-quote">'</code><code class="variable-op">: </code>-2147483647<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">i8</code><code class="variable-quote">'</code><code class="variable-op">: </code>-9223372036854775806<code class="variable-op">,</code>
<code class="variable-ellipsis">...</code>
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th bgcolor="#70b0f0" class="navbar-select"
          >&nbsp;&nbsp;&nbsp;Home&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1 on Thu Aug 28 13:53:20 2014
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
