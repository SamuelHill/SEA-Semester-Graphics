<!DOCTYPE html>
<html lang="en">
<head></head>
<body style="margin: 0;">
	<script src="js/three.min.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/topo.js"></script>
	<script src="js/currents.js"></script>
	<script src="js/dat.gui.min.js"></script>
	<script src="js/OceanShaders.js"></script>
	<script src="js/Ocean.js"></script>
	<script src="js/chroma.min.js"></script>
	<script src="js/tween.min.js"></script>
	<script>
		// Basics...
		var WIDTH, HEIGHT;
		var scene, camera, renderer;
		// Sets up topography based off the threejs examples -> webgl_geometry_terrain.html
		var topography, topoWidth = 180, topoDepth = 180, topoGeometry, topoPosition, topoTexture;
		// Sets up the basic information for creating the current arrows
		var arrowHelper, origin, direction, magnitude;
		var objects = [];
		var raycaster = new THREE.Raycaster();
		var mouse = new THREE.Vector2();
		// Variables for the ocean shader from threejs
		var ocean, gsize = 2000, res = 1024, gres = res/2, origx = -gsize/2, origz = -gsize/2;
		// GUI menu variables
		var gui = new dat.GUI();
		var displayOcean = true;
		var oceanDisplay = {displayOcean:true};
		var folder1=gui.addFolder("Current Details");
		var effectController={magnitude:"0 mm/s", depth:"0.0 m" , latitude: "0", longitude: "0"};
		var folder2=gui.addFolder("Ocean Animation");
		

		// Initialize...
		init();
		// gets the initial time for the animation
		var lastTime = (new Date()).getTime(), currentTime;
		animate();

		// Sets up the scene.
		function init() {
			// Only needed in fullscreen version
			// var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
			// Otherwise, manual...
			var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
			// Set up and add renderer to document
			renderer = new THREE.WebGLRenderer({antialias:true});
			renderer.setSize(WIDTH, HEIGHT);
			renderer.setClearColor(0x333F47, 1);
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.context.getExtension('OES_texture_float');
			renderer.context.getExtension('OES_texture_float_linear');
			renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.body.appendChild(renderer.domElement);

			// Setup camera and controls
			camera = new THREE.PerspectiveCamera(60, WIDTH / HEIGHT, 1, 20000);
			camera.position.set(1574,407,197);
			camera.lookAt(new THREE.Vector3());
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.maxDistance = 5000.0;
			controls.minDistance = 10;

			// Only needed in fullscreen version
			// window.addEventListener('resize', function() {
			// 	var WIDTH = window.innerWidth,
			// 		HEIGHT = window.innerHeight;
			// 	renderer.setSize(WIDTH, HEIGHT);
			// 	camera.aspect = WIDTH / HEIGHT;
			// 	camera.updateProjectionMatrix();
			// });

			// Scene:
			scene = new THREE.Scene();

			// Lights
			scene.add(new THREE.AmbientLight(0xffffff));
			var dlight = new THREE.DirectionalLight(0xffffff, 1); 
			dlight.position.set(0, 500, 0);
			scene.add(dlight);

			// Topography
			topoGeometry = new THREE.PlaneBufferGeometry(2000, 2000, topoWidth - 1, topoDepth - 1);
			topoGeometry.rotateX(-Math.PI/2);
			topoPosition = topoGeometry.getAttribute("position");
			var Y_list = [];
			for (var i = 0; i < topoPosition.count; i ++) {
				topoPosition.setXYZ(i, topo[i][0], topo[i][1] * 10, topo[i][2]);
				Y_list[i] = topo[i][1];
			}
			topoTexture = new THREE.CanvasTexture(generateTexture(Y_list, topoWidth, topoDepth));
			topoTexture.wrapS = THREE.ClampToEdgeWrapping;
			topoTexture.wrapT = THREE.ClampToEdgeWrapping;
			topography = new THREE.Mesh(topoGeometry, new THREE.MeshPhongMaterial({ map: topoTexture, side: THREE.DoubleSide}));
			scene.add(topography);

			// Currents
			var multiplier = 5000;
			var colorScale = chroma.scale(['yellow', 'navy']).mode('hsl');
			var max_mag = 0, min_mag = 0;
			for (var i = 0; i < currents.length; i++) {
				magnitude = Math.sqrt((currents[i][3]*currents[i][3]) + (currents[i][4]*currents[i][4]));
				if (magnitude > max_mag) {
					max_mag = magnitude;
				}
				else if (magnitude < min_mag) {
					min_mag = magnitude;
				}
			}
			for (var i = 0; i < currents.length; i++) {
				origin = new THREE.Vector3(currents[i][0],currents[i][1] * 10,currents[i][2]);
				direction = new THREE.Vector3(currents[i][3],0,currents[i][4]);
				direction.normalize();
				magnitude = Math.sqrt((currents[i][3]*currents[i][3]) + (currents[i][4]*currents[i][4]));
				if (magnitude == 0) {
					// Some magnitudes become 0, probably rounding error.
					// throws error found here:
					// https://github.com/mrdoob/three.js/issues/5160
					// Found the 0 magnitudes in this if: console.log("Problem child: " + i);
					magnitude = 0.0001
				}
				// Used this else if to find the lowest magnitude for above:
				// else if (magnitude < lowest_mag) { lowest_mag = magnitude; }
				// lowest_mag is 0.00011762002387144652 so .0001 is chosen to get all
				// 0 magnitudes above 0 but while still lower than the lowest.
				color = colorScale((magnitude - min_mag)/(max_mag - min_mag)).hex();
				arrowHelper = new THREE.ArrowHelper(direction, origin, multiplier*magnitude, color);
				scene.add(arrowHelper);
				objects.push([arrowHelper.cone, arrowHelper.line]);
			}

			// Ocean
			addOcean();

			// GUI
			gui.add(oceanDisplay, 'displayOcean').onChange(function(newValue) {
				displayOcean = newValue;
				if (newValue) {
					addOcean();
				} else {
					removeOcean();
				}
				animate();
			});

			var c2 = folder2.add(ocean, "choppiness", 0.1, 4);
			c2.onChange(function (v) {
				this.object.choppiness = v;
				this.object.changed = true;
			});
			var c3 = folder2.add(ocean, "windX",-15, 15);
			c3.onChange(function (v) {
				this.object.windX = v;
				this.object.changed = true;
			});
			var c4 = folder2.add(ocean, "windY", -15, 15);
			c4.onChange(function (v) {
				this.object.windY = v;
				this.object.changed = true;
			});
			var c8 = folder2.add(ocean, "exposure", 0.0, 0.5);
			c8.onChange(function (v) {
				this.object.exposure = v;
				this.object.changed = true;
			});
			var c9=folder1.add(effectController,"magnitude").name("Magnitude").listen();
			var c12=folder1.add(effectController,"depth").name("Depth").listen();
			var c13=folder1.add(effectController,"longitude").name("Longitude").listen();
			var c14=folder1.add(effectController,"latitude").name("Latitude").listen();
		}

		function removeOcean() {
			scene.remove(scene.getObjectByName("ocean"));
		}

		function addOcean() {
			ocean = new THREE.Ocean(renderer, camera, scene, {
				USE_HALF_FLOAT : true,
				INITIAL_SIZE : 256.0,
				INITIAL_WIND : [3.0, 3.0],
				INITIAL_CHOPPINESS : 0.5,
				CLEAR_COLOR : [1.0, 1.0, 1.0, 0.0],
				GEOMETRY_ORIGIN : [origx, origz],
				SUN_DIRECTION : [-1.0, 1.0, 1.0],
				OCEAN_COLOR: new THREE.Vector3(0.004, 0.016, 0.047),
				SKY_COLOR: new THREE.Vector3(3.2, 9.6, 12.8),
				EXPOSURE : 0.35,
				GEOMETRY_RESOLUTION: gres,
				GEOMETRY_SIZE : gsize,
				RESOLUTION : res
			});
			ocean.materialOcean.uniforms.u_projectionMatrix = {type: "m4", value: camera.projectionMatrix};
			ocean.materialOcean.uniforms.u_viewMatrix = {type: "m4", value: camera.matrixWorldInverse};
			ocean.materialOcean.uniforms.u_cameraPosition = {type: "v3", value: camera.position};
			ocean.oceanMesh.name = "ocean";
			scene.add(ocean.oceanMesh);
		}

		function animate() {
			requestAnimationFrame(animate);
			currentTime = new Date().getTime();
			if (displayOcean) {
				// Ocean shader updating...
				ocean.deltaTime = (currentTime - lastTime) / 1000 || 0.0;
				ocean.render(ocean.deltaTime);
				ocean.overrideMaterial = ocean.materialOcean;
				if (ocean.changed) {
					ocean.materialOcean.uniforms.u_size.value = ocean.size;
					ocean.materialOcean.uniforms.u_sunDirection.value.set( ocean.sunDirectionX, ocean.sunDirectionY, ocean.sunDirectionZ );
					ocean.materialOcean.uniforms.u_exposure.value = ocean.exposure;
					ocean.changed = false;
				}
				ocean.materialOcean.uniforms.u_normalMap.value = ocean.normalMapFramebuffer ;
				ocean.materialOcean.uniforms.u_displacementMap.value = ocean.displacementMapFramebuffer ;
				ocean.materialOcean.uniforms.u_projectionMatrix.value = camera.projectionMatrix ;
				ocean.materialOcean.uniforms.u_viewMatrix.value = camera.matrixWorldInverse ;
				ocean.materialOcean.uniforms.u_cameraPosition.value = camera.position;
				ocean.materialOcean.depthTest = true;
			}
			// Ordinary animation info.. update renderer and controls
			render();
			controls.update();
			lastTime = currentTime;
		}

		function render() {
			renderer.render(scene, camera);
		}
		
		function onDocumentMouseDown( event ) {
			event.preventDefault();
			mouse.x = (event.clientX/renderer.domElement.clientWidth) * 2 - 1;
			mouse.y = -(event.clientY/renderer.domElement.clientHeight) * 2 + 1;
			raycaster.setFromCamera(mouse, camera);
			raycaster.linePrecison = 3;
			var intersects = raycaster.intersectObjects(scene.children, true);
			if (intersects.length > 0) {
				for (var i = 0; i < objects.length; i++) {
					if (intersects[0].object === objects[i][0] || intersects[0].object === objects[i][1]) {
						objects[i][0].material.emmisive = new THREE.Color(0xffffff);
						objects[i][1].material.emmisive = new THREE.Color(0xffffff);
						effectController.magnitude=currents[i][8] + " mm/s";
						effectController.depth=currents[i][7] + " m";
						effectController.longitude=currents[i][6];
						effectController.latitude=currents[i][5];
						
						var translationVector=new THREE.Vector3(currents[i][3],currents[i][4],0);
						translationVector.normalize();
						var magni = Math.sqrt((currents[i][3]^2) + (currents[i][4]^2))
						translationVector.multiplyScalar(5*magni);
						var obj=new THREE.Object3D(objects[i][0].parent);
						obj.add(objects[i][0].parent);
						//obj.position.copy(objects[i][0].parent.position);
						scene.add(obj);
						
						obj.translateX(translationVector.x);
						obj.translateZ(translationVector.y);
					}
				}
			}
		}
			
		// Method from threejs examples -> webgl_geometry_terrain.html
		function generateTexture(data, width, height) {
			var canvas, context, image, canvasScaled, imageData, vector3, sunVector, shade;
			vector3 = new THREE.Vector3(0, 0, 0);
			// To change the look of the sea floor (where light falls...), change sunVector
			sunVector = new THREE.Vector3(4, 5, 6); // 1, 1, 1
			sunVector.normalize();
			// Preps canvas for texture...
			canvas = document.createElement('canvas');
			canvas.width = width;
			canvas.height = height;
			context = canvas.getContext('2d');
			context.fillStyle = '#000';
			context.fillRect(0, 0, width, height);
			image = context.getImageData(0, 0, canvas.width, canvas.height);
			imageData = image.data;
			// Generate texture...
			for (var i = 0, j = 0, l = imageData.length; i < l; i += 4, j++) {
				vector3.x = data[j - 2] - data[j + 2];
				vector3.y = 2;
				vector3.z = data[j - width * 2] - data[j + width * 2];
				vector3.normalize();
				shade = vector3.dot(sunVector);
				imageData[i] = (96 + shade * 128) * (0.5 + data[j] * 0.007);
				imageData[i + 1] = (32 + shade * 96) * (0.5 + data[j] * 0.007);
				imageData[i + 2] = (shade * 96) * (0.5 + data[j] * 0.007);
			}
			// Add shading (light amount) and scale...
			context.putImageData(image, 0, 0);
			canvasScaled = document.createElement('canvas');
			canvasScaled.width = width * 4;
			canvasScaled.height = height * 4;
			context = canvasScaled.getContext('2d');
			context.scale(4, 4);
			context.drawImage(canvas, 0, 0);
			image = context.getImageData(0, 0, canvasScaled.width, canvasScaled.height);
			imageData = image.data;
			// Adds randomized lighting/shade differences for more "realistic" sea floor
			for (var i = 0; i < imageData.length; i += 4) {
				var v = ~~ (Math.random() * 5);
				imageData[i] += v;
				imageData[i + 1] += v;
				imageData[i + 2] += v;
			}
			context.putImageData(image, 0, 0);
			return canvasScaled;
		}
	</script>
</body>
</html>